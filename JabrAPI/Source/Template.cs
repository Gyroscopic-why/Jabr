using System;
using System.Collections.Generic;


using AVcontrol;



namespace JabrAPI.Source
{
    public class Template
    {
        abstract public class IEncryptionKey
        {
            protected readonly SecureRandom _random = new(128);  //  Reseed after every 128 generated bytes (min possible amount)
            protected readonly Noisifier _noisifier = new();
            protected readonly List<Int16>  _shifts = [0];
            protected Int32 _shCount = 0;



            public Noisifier Noisifier => _noisifier;
            public List<Int16>  Shifts => _shifts;
            public Int32 ShAmount => _shifts == null ? -1 : _shifts.Count;
            public Int32 ShLength => _shifts == null ? -1 : _shifts.Count;
            public Int32 ShCount  => _shifts == null ? -1 : _shifts.Count;

            abstract public string FinalAlphabet { get; }



            public void Next(bool resetSettingsToDefaultIfFailed = true, bool throwExceptions = true)
            {
                try
                {
                    GenerateAll();
                }
                catch
                {
                    if (resetSettingsToDefaultIfFailed)
                    {
                        try
                        {
                            DefaultGenerate();
                        }
                        catch
                        {
                            if (throwExceptions) throw;
                        }
                    }
                    else if (throwExceptions) throw;
                }
            }



            abstract public bool   ImportFromString(string data, bool throwExceptions = false);
            abstract public string ExportAsString();



            abstract public bool ImportFromBinary(List<Byte> data, bool throwExceptions = false);
            abstract public List<Byte> ExportAsBinary();



            public void SetShiftCount(Int32 count) => _shCount = count;


            abstract public void SetDefault();

            protected void DefaultGenerate()
            {
                SetDefault();
                GenerateAll();
            }
            abstract protected private void GenerateAll();



            public void GenerateRandomShifts(Int32 count, Int16 minVal, Int16 maxVal)
            {
                if (count < 0)
                {
                    throw new ArgumentOutOfRangeException
                    (
                        nameof(count),
                        "count cannot be negative"
                    );
                }
                else if (minVal > maxVal)
                {
                    throw new ArgumentException
                    (
                        "min value cannot be greater than max value",
                        "minVal, maxVal"
                    );
                }
                else if (minVal < 0)
                {
                    throw new ArgumentOutOfRangeException
                    (
                        nameof(minVal),
                        "minVal cannot be negative"
                    );
                }

                _shifts.Clear();
                if (count == 0)
                {
                    _shifts.Add(0);
                    return;
                }

                for (var curId = 0; curId < count; curId++)
                    _shifts.Add((Int16)_random.Next(minVal, maxVal));
            }
            public void GenerateRandomShifts(Int16 minVal, Int16 maxVal)
                => GenerateRandomShifts(_random.Next(256, 512), minVal, maxVal);
        }

        abstract public class IBinaryKey
        {
            protected readonly SecureRandom _random = new(128);  //  Reseed after every 128 generated bytes (min possible amount)
            protected readonly BinaryNoisifier _noisifier = new();

            protected readonly List<Byte> _shifts = [0];
            protected Byte _shCount = 0;



            public BinaryNoisifier Noisifier => _noisifier;
            public List<Byte> Shifts => _shifts;
            public Int32 ShAmount => _shifts == null ? -1 : _shifts.Count;
            public Int32 ShLength => _shifts == null ? -1 : _shifts.Count;
            public Int32 ShCount  => _shifts == null ? -1 : _shifts.Count;

            abstract public List<Byte> FinalAlphabet { get; }



            public void Next(bool resetSettingsToDefaultIfFailed = true, bool throwExceptions = true)
            {
                try
                {
                    GenerateAll();
                }
                catch
                {
                    if (resetSettingsToDefaultIfFailed)
                    {
                        try
                        {
                            DefaultGenerate();
                        }
                        catch
                        {
                            if (throwExceptions) throw;
                        }
                    }
                    else if (throwExceptions) throw;
                }
            }



            abstract public bool ImportFromBinary(List<Byte> data, bool throwExceptions = false);

            abstract public List<Byte> ExportAsBinary();



            public void SetShiftCount(Byte count) => _shCount = count;


            abstract public void SetDefault();
            protected void DefaultGenerate()
            {
                SetDefault();
                GenerateAll();
            }
            abstract protected private void GenerateAll();



            public void GenerateRandomShifts(Int32 count, Byte minVal, Byte maxVal)
            {
                if (count < 0)
                {
                    throw new ArgumentOutOfRangeException
                    (
                        nameof(count),
                        "count cannot be negative"
                    );
                }
                else if (minVal > maxVal)
                {
                    throw new ArgumentException
                    (
                        "min value cannot be greater than max value",
                        "minVal, maxVal"
                    );
                }
                else if (minVal < 0)
                {
                    throw new ArgumentOutOfRangeException
                    (
                        nameof(minVal),
                        "minVal cannot be negative"
                    );
                }

                _shifts.Clear();
                if (count == 0)
                {
                    _shifts.Add(0);
                    return;
                }

                for (var curId = 0; curId < count; curId++)
                    _shifts.Add(_random.Next(minVal, maxVal));
            }
            public void GenerateRandomShifts(Byte minVal, Byte maxVal)
                => GenerateRandomShifts(_random.Next(256, 512), minVal, maxVal);
        }
    }
}