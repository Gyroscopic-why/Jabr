using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;


using AVcontrol;


namespace JabrAPI
{
    public class Noisifier
    {
        private readonly SecureRandom _random = new(128);  //  Reseed after every 128 generated bytes (min possible amount)
        public  NoisificationSettings settings = new();

        private string _primaryNoise = "";
        private string _complexNoise = "";

        private readonly List<char> _banned = [];
        private Int32  _primaryCount = 8;
        private Int32  _complexCount = 16;



        public Noisifier(string primaryNoise, string complexNoise)
            => Set(primaryNoise, complexNoise);
        public Noisifier(Noisifier otherNoisifier, bool fullCopy = true)
            => CopyFrom(otherNoisifier, fullCopy);
        public Noisifier(List<char> banned, bool autoGenerate = true)
        {
            if (autoGenerate) DefaultGenerate(banned);
            else SetDefault(banned);
        }
        public Noisifier(List<Byte> exported) => ImportFromBinary(exported);
        public Noisifier()
            => SetDefault();



        public Int32 PrimaryNoiseCount => _primaryNoise.Length;
        public Int32 ComplexNoiseCount => _complexNoise.Length;

        public string PrimaryNoise => _primaryNoise;
        public string ComplexNoise => _complexNoise;
        public List<char> Banned   => _banned;

        public char RandomPrimaryChar => _primaryNoise[_random.Next(PrimaryNoiseCount)];
        public char RandomComplexChar => _complexNoise[_random.Next(ComplexNoiseCount)];

        public string RandomPrimarySequence(Int32 count) =>
            string.Concat(Enumerable.Range(0, count).Select
            (
                _ => _primaryNoise[_random.Next(PrimaryNoiseCount)]
            )
        );
        public string RandomComplexSequence(Int32 count) =>
            string.Concat(Enumerable.Range(0, count).Select
            (
                _ => _complexNoise[_random.Next(ComplexNoiseCount)]
            )
        );





        static public bool IsPrimaryNoiseValidForKey(Template.IEncryptionKey reKey, string primaryNoise, bool throwException = false)
            => IsPrimaryNoiseValidForKey(reKey.FinalAlphabet, primaryNoise, throwException);
        static public bool IsPrimaryNoiseValidForKey(string  exAlphabet, string primaryNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                exAlphabet,
                primaryNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with ExternalAlphabet chars",
                    nameof(primaryNoise)
                ),
                throwException
            );
        }
        static public bool IsPrimaryNoiseValidForMessage(string message, string primaryNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                message,
                primaryNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with message chars",
                    nameof(primaryNoise)
                ),
                throwException
            );
        }

        public bool IsPrimaryNoiseValidForKey(Template.IEncryptionKey reKey, bool throwException = false)
            => IsPrimaryNoiseValidForKey(reKey.FinalAlphabet, _primaryNoise, throwException);
        public bool IsPrimaryNoiseValidForKey(string exAlphabet,  bool throwException = false)
            => IsPrimaryNoiseValidForKey(exAlphabet,  _primaryNoise, throwException);
        public bool IsPrimaryNoiseValidForMessage(string message, bool throwException = false)
            => IsPrimaryNoiseValidForMessage(message, _primaryNoise, throwException);


        static public bool IsComplexNoiseValidForKey(Template.IEncryptionKey reKey, string complexNoise, bool throwException = false)
            => IsComplexNoiseValidForKey(reKey.FinalAlphabet, complexNoise, throwException);
        static public bool IsComplexNoiseValidForKey(string  exAlphabet, string complexNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                exAlphabet,
                complexNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with ExternalAlphabet chars",
                    nameof(complexNoise)
                ),
                throwException
            );
        }
        static public bool IsComplexNoiseValidForMessage(string message, string complexNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                message,
                complexNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with message chars",
                    nameof(complexNoise)
                ),
                throwException
            );
        }

        public bool IsComplexNoiseValidForKey(Template.IEncryptionKey reKey, bool throwException = false)
            => IsComplexNoiseValidForKey(reKey.FinalAlphabet, _complexNoise, throwException);
        public bool IsComplexNoiseValidForKey(string exAlphabet,  bool throwException = false)
            => IsComplexNoiseValidForKey(exAlphabet,  _complexNoise, throwException);
        public bool IsComplexNoiseValidForMessage(string message, bool throwException = false)
            => IsComplexNoiseValidForMessage(message, _complexNoise, throwException);



        static private bool IsNoiseValid(string exAlphabet_or_message, string primaryNoise_or_complexNoise,
            ArgumentException errorMessage, bool throwException = false)
        {
            foreach (char noiseChar in primaryNoise_or_complexNoise)
            {
                if (exAlphabet_or_message.Contains(noiseChar))
                {
                    if (throwException) throw new ArgumentException
                        (
                            errorMessage.Message +
                            $"\nDuplicate char: {noiseChar}",
                            errorMessage.ParamName
                        );
                    return false;
                }
            }
            return true;
        }





        public void Next(bool throwExceptions = true)
        {
            try { GenerateAll(); }
            catch { if (throwExceptions) throw; }
        }
        public void Next(List<char> bannedForFailsafeRegeneration,
            bool resetSettingsToDefaultIfFailed = true, bool throwExceptions = true)
        {
            try
            {
                GenerateAll();
            }
            catch
            {
                if (resetSettingsToDefaultIfFailed)
                {
                    try
                    {
                        DefaultGenerate(bannedForFailsafeRegeneration);
                    }
                    catch
                    {
                        if (throwExceptions) throw;
                    }
                }
                else if (throwExceptions) throw;
            }
        }



        public bool ImportFromString(string data, bool throwExceptions = false)
        {
            try
            {
                Int32 splitterId = data.IndexOf(':'), offset, parsedLength;

                if (splitterId == -1)
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Data doesnt contain splitter for determining PrimaryNoise length" +
                            $"\ndata.IndexOf(':') == -1",
                            nameof(data) + "," + nameof(splitterId)
                        );
                    return false;
                }
                else if (!Int32.TryParse(data.AsSpan(0, splitterId), out parsedLength))
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Unable to parse PrimaryNoise length" +
                            $"\nExpected length to be at indexes 0-{splitterId}" +
                            $"\nInvalid sequence: {data[..splitterId]}",
                            nameof(data) + "," + nameof(splitterId)
                        );
                    return false;
                }
                else if (data.Length < splitterId + 1 + parsedLength + 4)
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Data is insufficient for expected PrimaryNoise & smallest possible ComplexNoise" +
                            $"Data length: {data.Length}   <   expected: {splitterId + 1 + parsedLength + 4}",
                            nameof(data) + "," + nameof(splitterId) + "," + nameof(parsedLength)
                        );
                    return false;
                }

                _primaryNoise = data.Substring(splitterId + 1, parsedLength);


                offset = splitterId + 1 + parsedLength;
                splitterId = data.IndexOf(':', offset);

                if (splitterId == -1)
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Data doesnt contain another splitter for determining ComplexNoise length" +
                            $"\ndata.IndexOf(':') == -1",
                            nameof(data) + "," + nameof(splitterId)
                        );
                    return false;
                }
                else if (!Int32.TryParse(data.AsSpan(offset, splitterId - offset), out parsedLength))
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Unable to parse ComplexNoise length" +
                            $"\nExpected length to be at indexes {offset}-{splitterId}" +
                            $"\nInvalid sequence: {data[offset..]}",
                            nameof(data) + "," + nameof(splitterId)
                        );
                    return false;
                }
                else if (data.Length < splitterId + 1 + parsedLength)
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Data is insufficient for expected ComplexNoise" +
                            $"Data length: {data.Length}   <   expected: {splitterId + 1 + parsedLength}",
                            nameof(data) + "," + nameof(splitterId) + "," + nameof(parsedLength)
                        );
                    return false;
                }

                _complexNoise = data.Substring(splitterId + 1, parsedLength);
            }
            catch
            {
                if (throwExceptions) throw;
                return false;
            }
            return true;
        }
        public string ExportAsString()
            => _primaryNoise.Length + ":" + _primaryNoise +
               _complexNoise.Length + ":" + _complexNoise;
        
        public bool ImportFromBinary(List<Byte> data, bool throwExceptions = false)
        {
            try
            {
                Int32 primaryCount = FromBinary.BigEndian<Int32>
                (
                    [..
                        data.GetRange(0, 4)
                    ]
                );


                if (data.Count < primaryCount + 8)
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Data length is insufficient for the specified primaryNoiseCount" +
                            $" {primaryCount + 8} from data[0-4]",
                            nameof(data)
                        );
                    return false;
                }


                _primaryNoise = FromBinary.Utf16
                (
                    data.GetRange
                    (
                        4,
                        primaryCount
                    )
                );


                Int32 complexCount = FromBinary.BigEndian<Int32>
                (
                    [..
                        data.GetRange(primaryCount + 4, 4)
                    ]
                );

                if (data.Count < complexCount + primaryCount + 8)
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Data length is insufficient for the specified complexNoiseCount" +
                            $" {complexCount + primaryCount + 8}" +
                            $"from data[{primaryCount + 4}-{primaryCount+8}]",
                            nameof(data)
                        );
                    return false;
                }


                _complexNoise = FromBinary.Utf16
                (
                    data.GetRange
                    (
                        primaryCount + 8,
                        complexCount
                    )
                );
            }
            catch
            {
                if (throwExceptions) throw;
                return false;
            }
            return true;
        }
        public List<Byte> ExportAsBinary()
        {
            Byte[] exportedPrimary = ToBinary.Utf16(_primaryNoise);
            Byte[] exportedComplex = ToBinary.Utf16(_complexNoise);

            return
            [
                .. ToBinary.BigEndian(exportedPrimary.Length),
                .. exportedPrimary,

                .. ToBinary.BigEndian(exportedComplex.Length),
                .. exportedComplex
            ];
        }



        public void SetDefault(List<char> banned, Int32 primaryCount, Int32 complexCount)
        {
            _banned.Clear();
            _banned.AddRange(banned);

            SetDefault(primaryCount, complexCount);
        }
        public void SetDefault(Int32 primaryCount = 8, Int32 complexCount = 16)
        {
            _primaryCount = primaryCount;
            _complexCount = complexCount;
        }
        public void SetDefault(List<char> banned)
        {
            _banned.Clear();
            _banned.AddRange(banned);
        }

        public void SetDefaultOnlyPr(Int32 primaryCount = 8)
            => _primaryCount = primaryCount;
        public void SetDefaultOnlyCplx(Int32 complexCount = 16)
            => _complexCount = complexCount;

        public  void DefaultGenerate(List<char> banned)
        {
            SetDefault(banned);
            GenerateAll();
        }
        public  void CopyFrom(Noisifier otherNoisifier, bool fullCopy = true)
        {
            Set(otherNoisifier.PrimaryNoise, otherNoisifier.ComplexNoise);

            if (fullCopy)
                SetDefault
                (
                    otherNoisifier.Banned,
                    otherNoisifier._primaryCount,
                    otherNoisifier._complexCount
                );
        }
        private void Set(string primaryNoise, string complexNoise)
        {
            _primaryNoise = primaryNoise;
            _complexNoise = complexNoise;
        }



        private void GenerateAll()
        {
            GeneratePrimary(false);
            GenerateComplex(true);
        }



        private void ReconfigureNoiseParametersCount(Int32 allowedTotal)
        {
            if (allowedTotal < _primaryCount + _complexCount)
            {
                Int32 compromiseLeft = allowedTotal / 3;
                _primaryCount = compromiseLeft;
                _complexCount = allowedTotal - compromiseLeft;
            }
        }
        private List<char> GetRemainingAllowed(List<char> banned, Int32 targetCount, bool banAlreadyUsed)
        {
            List<char> result = [.. DEFAULT.CHARACTERS.WITHOUT_SPACE];

            if (!banAlreadyUsed) ReconfigureNoiseParametersCount(256 - banned.Count);
            else foreach (char bannedChar in _primaryNoise == ""
                    ? _complexNoise : _primaryNoise)
                    result.RemoveAll(c => c == bannedChar);

            foreach (char bannedChar in banned)
                    result.RemoveAll(c => c == bannedChar);


            Int32 chosenId, curCount = result.Count;
            while (curCount > targetCount)
            {
                chosenId = _random.Next(curCount);

                result.RemoveRange
                (
                    chosenId,
                    Math.Min
                    (                        
                        curCount - chosenId - 1,
                        _random.Next(1, curCount - targetCount)
                    )
                );

                curCount = result.Count;
            }

            return result;
        }



        public string GenerateNoise(int count, List<char> allowed)
        {
            if (count <= 0) return string.Empty;
            if (count > allowed.Count) throw new ArgumentOutOfRangeException
                (
                    $"Count is greater than max possible length: {allowed.Count}"
                );

            StringBuilder result = new(count);
            Int32 totalCount = allowed.Count;

            for (var lastUsedId = 0; lastUsedId < count; lastUsedId++)
            {
                Int32 chosenUnused = _random.Next(lastUsedId, totalCount);

                (allowed[lastUsedId], allowed[chosenUnused]) =
                (allowed[chosenUnused], allowed[lastUsedId]);

                result.Append(allowed[lastUsedId]);
            }

            return result.ToString();
        }



        public void GeneratePrimary(List<char> banned, bool banAlreadyUsedInComplex)
        {
            //  Important to get allowed separately from GenerateNoise
            //  because _primaryCount can change here in default fail case
            _primaryNoise = "";
            List<char> allowed = GetRemainingAllowed(banned, _primaryCount, banAlreadyUsedInComplex);

            _primaryNoise = GenerateNoise(_primaryCount, allowed);
        }
        public void GeneratePrimary(bool banAlreadyUsedInComplex)
            => GeneratePrimary(_banned, banAlreadyUsedInComplex);

        public void GenerateComplex(List<char> banned, bool banAlreadyUsedInPrimary)
        {
            //  Important to get allowed separately from GenerateNoise
            //  because _complexCount can change here in default fail case
            _complexNoise = "";
            List<char> allowed = GetRemainingAllowed(banned, _complexCount, banAlreadyUsedInPrimary);

            _complexNoise = GenerateNoise(_complexCount, allowed);
        }
        public void GenerateComplex(bool banAlreadyUsedInPrimary)
            => GenerateComplex(_banned, banAlreadyUsedInPrimary);
    }

    public class BinaryNoisifier
    {
        private readonly SecureRandom _random = new(128);  //  Reseed after every 128 generated bytes (min possible amount)

        private readonly List<Byte> _primaryNoise = [];
        private readonly List<Byte> _complexNoise = [];

        private readonly List<Byte> _banned = [];
        private Byte _primaryCount = 8;
        private Byte _complexCount = 16;



        public BinaryNoisifier(List<Byte> primaryNoise, List<Byte> complexNoise)
            => Set(primaryNoise, complexNoise);
        public BinaryNoisifier(BinaryNoisifier otherNoisifier, bool fullCopy = true)
            => Copy(otherNoisifier, fullCopy);
        public BinaryNoisifier(List<Byte> banned, bool autoGenerate = true)
        {
            if (autoGenerate) DefaultGenerate(banned);
            else SetDefault(banned);
        }
        public BinaryNoisifier(List<Byte> exported) => ImportFromBinary(exported);
        public BinaryNoisifier()
            => SetDefault();



        public Int32 PrimaryNoiseCount => _primaryNoise.Count;
        public Int32 ComplexNoiseCount => _complexNoise.Count;

        public List<Byte> PrimaryNoise => _primaryNoise;
        public List<Byte> ComplexNoise => _complexNoise;
        public List<Byte> Banned => _banned;

        public Byte RandomPrimaryByte => _primaryNoise[_random.Next(PrimaryNoiseCount)];
        public Byte RandomComplexByte => _complexNoise[_random.Next(ComplexNoiseCount)];
        




        static public bool IsPrimaryNoiseValidForKey(Template.IBinaryKey reKey, List<Byte> primaryNoise, bool throwException = false)
            => IsPrimaryNoiseValidForKey(reKey.FinalAlphabet, primaryNoise, throwException);
        static public bool IsPrimaryNoiseValidForKey(List<Byte>  exAlphabet, List<Byte> primaryNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                exAlphabet,
                primaryNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with ExternalAlphabet bytes",
                    nameof(primaryNoise)
                ),
                throwException
            );
        }
        static public bool IsPrimaryNoiseValidForMessage(List<Byte> message, List<Byte> primaryNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                message,
                primaryNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with message bytes",
                    nameof(primaryNoise)
                ),
                throwException
            );
        }

        public bool IsPrimaryNoiseValidForKey(Template.IBinaryKey reKey, bool throwException = false)
            => IsPrimaryNoiseValidForKey(reKey.FinalAlphabet, _primaryNoise, throwException);
        public bool IsPrimaryNoiseValidForKey(List<Byte> exAlphabet,  bool throwException = false)
            => IsPrimaryNoiseValidForKey(exAlphabet,  _primaryNoise,  throwException);
        public bool IsPrimaryNoiseValidForMessage(List<Byte> message, bool throwException = false)
            => IsPrimaryNoiseValidForMessage(message, _primaryNoise,  throwException);


        static public bool IsComplexNoiseValidForKey(Template.IBinaryKey reKey, List<Byte> complexNoise, bool throwException = false)
            => IsComplexNoiseValidForKey(reKey.FinalAlphabet, complexNoise, throwException);
        static public bool IsComplexNoiseValidForKey(List<Byte>  exAlphabet, List<Byte> complexNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                exAlphabet,
                complexNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with ExternalAlphabet bytes",
                    nameof(complexNoise)
                ),
                throwException
            );
        }
        static public bool IsComplexNoiseValidForMessage(List<Byte> message, List<Byte> complexNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                message,
                complexNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with message bytes",
                    nameof(complexNoise)
                ),
                throwException
            );
        }

        public bool IsComplexNoiseValidForKey(Template.IBinaryKey reKey, bool throwException = false)
            => IsComplexNoiseValidForKey(reKey.FinalAlphabet, _complexNoise, throwException);
        public bool IsComplexNoiseValidForKey(List<Byte> exAlphabet,  bool throwException = false)
            => IsComplexNoiseValidForKey(exAlphabet,  _complexNoise,  throwException);
        public bool IsComplexNoiseValidForMessage(List<Byte> message, bool throwException = false)
            => IsComplexNoiseValidForMessage(message, _complexNoise,  throwException);



        static private bool IsNoiseValid(List<Byte> exAlphabet_or_message, List<Byte> primaryNoise_or_complexNoise,
            ArgumentException errorMessage, bool throwException = false)
        {
            foreach (Byte noiseByte in primaryNoise_or_complexNoise)
            {
                if (exAlphabet_or_message.Contains(noiseByte))
                {
                    if (throwException) throw new ArgumentException
                        (
                            errorMessage.Message +
                            $"\nDuplicate byte: {noiseByte}",
                            errorMessage.ParamName
                        );
                    return false;
                }
            }
            return true;
        }





        public void Next(bool throwExceptions = true)
        {
            try { GenerateAll(); }
            catch { if (throwExceptions) throw; }
        }
        public void Next(List<Byte> bannedForFailsafeRegeneration,
            bool resetSettingsToDefaultIfFailed = true, bool throwExceptions = true)
        {
            try
            {
                GenerateAll();
            }
            catch
            {
                if (resetSettingsToDefaultIfFailed)
                {
                    try
                    {
                        DefaultGenerate(bannedForFailsafeRegeneration);
                    }
                    catch
                    {
                        if (throwExceptions) throw;
                    }
                }
                else if (throwExceptions) throw;
            }
        }



        public bool ImportFromBinary(List<Byte> data, bool throwExceptions = false)
        {
            try
            {
                Byte primaryCount = data[0];
                if (data.Count < primaryCount + 1)
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Data length is insufficient for the specified primaryNoiseCount" +
                            $" {primaryCount} from data[0]",
                            nameof(data)
                        );
                    return false;
                }

                _primaryNoise.Clear();
                _primaryNoise.AddRange(data.GetRange(1, primaryCount));


                Byte complexCount = data[primaryCount + 1];
                if (data.Count < complexCount + primaryCount + 2)
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Data length is insufficient for the specified complexNoiseCount" +
                            $" {complexCount} from data[{primaryCount + 2}]",
                            nameof(data)
                        );
                    return false;
                }

                _complexNoise.Clear();
                _complexNoise.AddRange(data.GetRange(primaryCount + 2, complexCount));
            }
            catch
            {
                if (throwExceptions) throw;
                return false;
            }
            return true;
        }

        public List<Byte> ExportAsBinary()
        {
            List<Byte> result = [];

            result.Add((Byte)(_primaryNoise.Count));
            result.AddRange(_primaryNoise);

            result.Add((Byte)(_complexNoise.Count));
            result.AddRange(_complexNoise);

            return result;
        }



        public void SetDefault(List<Byte> banned, Byte primaryCount, Byte complexCount)
        {
            _banned.Clear();
            _banned.AddRange(banned);

            SetDefault(primaryCount, complexCount);
        }
        public void SetDefault(Byte primaryCount = 8, Byte complexCount = 16)
        {
            _primaryCount = primaryCount;
            _complexCount = complexCount;
        }
        public void SetDefault(List<Byte> banned)
        {
            _banned.Clear();
            _banned.AddRange(banned);
        }

        public void SetDefaultOnlyPr(Byte primaryCount = 8)
            => _primaryCount = primaryCount;
        public void SetDefaultOnlyCplx(Byte complexCount = 16)
            => _complexCount = complexCount;

        public  void DefaultGenerate(List<Byte> banned)
        {
            SetDefault(banned);
            GenerateAll();
        }
        public  void Copy(BinaryNoisifier otherNoisifier, bool fullCopy = true)
        {
            Set(otherNoisifier.PrimaryNoise, otherNoisifier.ComplexNoise);

            if (fullCopy)
                SetDefault
                (
                    otherNoisifier.Banned,
                    otherNoisifier._primaryCount,
                    otherNoisifier._complexCount
                );
        }
        private void Set(List<Byte> primaryNoise, List<Byte> complexNoise)
        {
            _primaryNoise.Clear();
            _primaryNoise.AddRange(primaryNoise);

            _complexNoise.Clear();
            _complexNoise.AddRange(complexNoise);
        }



        private void GenerateAll()
        {
            GeneratePrimary(false);
            GenerateComplex(true);
        }



        private void ReconfigureNoiseParametersCount(Int32 allowedTotal)
        {
            if (allowedTotal < _primaryCount + _complexCount)
            {
                Byte compromiseLeft = (Byte)(allowedTotal / 3);
                _primaryCount = compromiseLeft;
                _complexCount = (Byte)(allowedTotal - compromiseLeft);
            }
        }
        private List<Byte> GetAllowedForDefaultCase(List<Byte> banned, Int32 reconfigureCount)
        {
            ReconfigureNoiseParametersCount(reconfigureCount);

            List<Byte> result = [];
            for (Byte noiseByte = 0; noiseByte < Byte.MaxValue; noiseByte++)
            {
                if (!banned.Contains(noiseByte)) result.Add(noiseByte);
            }
            return result;
        }
        private List<Byte> GetRemainingAllowedForPrimary(List<Byte> banned, bool banAlreadyUsedInComplex)
        {
            List<Byte> result = [];

            if (!banAlreadyUsedInComplex) result.AddRange(
                GetAllowedForDefaultCase(banned, 256 - banned.Count));
            else
            {
                for (Byte noiseByte = 0; noiseByte < Byte.MaxValue; noiseByte++)
                {
                    if (!banned.Contains(noiseByte) && !_complexNoise.Contains(noiseByte))
                        result.Add(noiseByte);
                }
            }

            while (result.Count > _primaryCount)
                result.RemoveAt(_random.Next(result.Count));

            return result;
        }
        private List<Byte> GetRemainingAllowedForComplex(List<Byte> banned, bool banAlreadyUsedInPrimary)
        {
            List<Byte> result = [];

            if (!banAlreadyUsedInPrimary) result.AddRange(
                GetAllowedForDefaultCase(banned, 256 - banned.Count));
            else
            {
                for (Byte noiseByte = 0; noiseByte < Byte.MaxValue; noiseByte++)
                {
                    if (!banned.Contains(noiseByte) && !_primaryNoise.Contains(noiseByte))
                        result.Add(noiseByte);
                }
            }

            while (result.Count > _complexCount)
                result.RemoveAt(_random.Next(result.Count));

            return result;
        }



        public List<Byte> GenerateNoise(Byte count, List<Byte> allowed)
        {
            List<Byte> result = [];

            for (var noiseByteId = 0; noiseByteId < count; noiseByteId++)
            {
                Int32 chosenId = _random.Next(result.Count);
                result.Insert(chosenId, allowed[noiseByteId]);
            }

            return result;
        }



        public void GeneratePrimary(List<Byte> banned, bool banAlreadyUsedInComplex)
        {
            //  Important to get allowed separately from GenerateNoise
            //  because _primaryCount can change here in default fail case
            _primaryNoise.Clear();
            List<Byte> allowed = GetRemainingAllowedForPrimary(banned, banAlreadyUsedInComplex);

            _primaryNoise.AddRange(GenerateNoise(_primaryCount, allowed));
        }
        public void GeneratePrimary(bool banAlreadyUsedInComplex)
            => GeneratePrimary(_banned, banAlreadyUsedInComplex);

        public void GenerateComplex(List<Byte> banned, bool banAlreadyUsedInPrimary)
        {
            //  Important to get allowed separately from GenerateNoise
            //  because _complexCount can change here in default fail case
            _complexNoise.Clear();
            List<Byte> allowed = GetRemainingAllowedForComplex(banned, banAlreadyUsedInPrimary);

            _complexNoise.AddRange(GenerateNoise(_complexCount, allowed));
        }
        public void GenerateComplex(bool banAlreadyUsedInPrimary)
            => GenerateComplex(_banned, banAlreadyUsedInPrimary);
    }





    public class NoisificationSettings
    {
        public Int32 outputLength = 0;

        public bool  useDynamicOutputAlignment = true;
        public CharacterOutputBoundaryAlignment boundaryAlignment = 
               CharacterOutputBoundaryAlignment.c1024;

        public bool forceOptimalEntropy = true;
        public ExpectedEntropy excpectedEntropy = ExpectedEntropy.C1_Medium;


        public double primaryNoiseCharBiasPercents = 50.0;
        public double complexNoisePairBiasPercents = 25.0;
        public double complexNoiseIntervalBiasPercents = 66.6;


        public Int32 chunkSizeForSplitting = 15;
    }
    public class BinaryNoisificationSettings
    {
        public Int32 outputLength = 0;

        public bool useDynamicOutputAlignment = true;
        public BinaryOutputBoundaryAlignment boundaryAlignment =
               BinaryOutputBoundaryAlignment.KByte1;

        public bool forceOptimalEntropy = true;
        public ExpectedEntropy excpectedEntropy = ExpectedEntropy.C1_Medium;


        public double primaryNoiseCharBiasPercents = 50.0;
        public double complexNoisePairBiasPercents = 25.0;
        public double complexNoiseIntervalBiasPercents = 66.6;


        public Int32 chunkSizeForSplitting = 256;
    }

    public enum BinaryOutputBoundaryAlignment
    {
        Byte32   = 5,
        Byte64   = 6,
        Byte128  = 7,
        Byte256  = 8,
        Byte512  = 9,
        
        KByte1   = 10,
        KByte2   = 11,
        KByte4   = 12,
        KByte8   = 13,
        KByte16  = 14,

        KByte32  = 15,
        KByte64  = 16,
        KByte128 = 17,
        KByte256 = 18,
        KByte512 = 19,

        MByte1   = 20
    }
    public enum CharacterOutputBoundaryAlignment
    {
        c32  = 5,
        c64  = 6,
        c128 = 7,
        c256 = 8,
        c512 = 9,

        c1024 = 10,
        c2048 = 11,
        c4096 = 12,
        c8192 = 13,

        c16384  = 14,
        c32768  = 15,
        c65536  = 16,
        c131072 = 17,
        c262144 = 18,
        c524288 = 19,

        c1048576 = 20
    }

    public enum ExpectedEntropy
    {
        L0_Fast_Anything,
        L1_Fast_Low,
        L2_Fast_Low,
        
        C0_Medium,
        C1_Medium,
        C2_Medium,
        
        H0_Slow_High,
        H1_Slow_High,
        H2_Slow_Maximal,
    }
    




    static public class AddNoise
    {
        static public string Text(string message, Template.IEncryptionKey reKey,
            out Exception? exception)
        {
            if (message == null || message == "" || message.Length < 1)
            {
                exception = new ArgumentException
                (
                    "Message is invalid - cannot be null or empty",
                    nameof(message)
                );
            }
            else if (reKey == null)
            {
                exception = new ArgumentException
                (
                    "Encryption key is undefined (null or empty)",
                    nameof(reKey)
                );
            }
            else if (reKey.Noisifier == null)
            {
                exception = new ArgumentException
                (
                    "Noisifier is undefined (null or empty)",
                    nameof(reKey.Noisifier)
                );
            }
            else
            {
                try
                {
                    reKey.Noisifier.IsComplexNoiseValidForKey(reKey, true);
                    reKey.Noisifier.IsPrimaryNoiseValidForKey(reKey, true);

                    reKey.Noisifier.IsComplexNoiseValidForMessage(message, true);
                    reKey.Noisifier.IsPrimaryNoiseValidForMessage(message, true);

                    string result = FastText(message, reKey);
                    exception = null;

                    return result;
                }
                catch (Exception innerException) { exception = innerException; }
            }
            return "";
        }
        static public string Text(string message, Template.IEncryptionKey reKey,
            bool throwException = false)
        {
            if (message == null || message == "" || message.Length < 1)
            {
                if (throwException)
                {
                    throw new ArgumentException
                    (
                        "Message is invalid - cannot be null or empty",
                        nameof(message)
                    );
                }
            }
            else if (reKey == null)
            {
                if (throwException)
                {
                    throw new ArgumentException
                    (
                        "Encryption key is undefined (null or empty)",
                        nameof(reKey)
                    );
                }
            }
            else if (reKey.Noisifier == null)
            {
                if (throwException)
                {
                    throw new ArgumentException
                    (
                        "Noisifier is undefined (null or empty)",
                        nameof(reKey.Noisifier)
                    );
                }
            }
            else if (reKey.Noisifier.IsPrimaryNoiseValidForKey(reKey, throwException)
                  && reKey.Noisifier.IsComplexNoiseValidForKey(reKey, throwException)
                  && reKey.Noisifier.IsPrimaryNoiseValidForMessage(message, throwException)
                  && reKey.Noisifier.IsComplexNoiseValidForMessage(message, throwException))
            {
                try
                {
                    return FastText(message, reKey);
                }
                catch (Exception) { if (throwException) throw;}
            }
            return "";
        }
        static public string FastText(string message, Template.IEncryptionKey reKey)
        {
            return OLD_INTERNAL_FastText
            (
                message,
                reKey.Noisifier,
                string.Concat
                (
                    new HashSet<char>
                    (reKey.FinalAlphabet)
                )
            );
        }


        static public string Text(string message, Noisifier noisifier,
            out Exception? exception)
        {
            if (message == null || message == "" || message.Length < 1)
            {
                exception = new ArgumentException
                (
                    "Message is invalid - cannot be null or empty",
                    nameof(message)
                );
            }
            else if (noisifier == null)
            {
                exception = new ArgumentException
                (
                    "Noisifier is undefined (null or empty)",
                    nameof(noisifier)
                );
            }
            else
            {
                try
                {
                    noisifier.IsComplexNoiseValidForMessage(message, true);
                    noisifier.IsPrimaryNoiseValidForMessage(message, true);

                    string result = FastText(message, noisifier);
                    exception = null;

                    return result;
                }
                catch (Exception innerException) { exception = innerException; }
            }
            return "";
        }
        static public string Text(string message, Noisifier noisifier,
            bool throwException = false)
        {
            if (message == null || message == "" || message.Length < 1)
            {
                if (throwException)
                {
                    throw new ArgumentException
                    (
                        "Message is invalid - cannot be null or empty",
                        nameof(message)
                    );
                }
            }
            else if (noisifier == null)
            {
                if (throwException)
                {
                    throw new ArgumentException
                    (
                        "Noisifier is undefined (null or empty)",
                        nameof(noisifier)
                    );
                }
            }
            else if (noisifier.IsComplexNoiseValidForMessage(message, throwException)
                  && noisifier.IsPrimaryNoiseValidForMessage(message, throwException))
            {
                try
                {
                    return FastText(message, noisifier);
                }
                catch (Exception) { if (throwException) throw; }
            }
            return "";
        }
        static public string FastText(string message, Noisifier noisifier)
        {
            return OLD_INTERNAL_FastText
            (
                message,
                noisifier,
                string.Concat
                (
                    new HashSet<char>
                    (message)
                )
            );
        }

        static private string OLD_INTERNAL_FastText(string message, Noisifier noisifier,
            string fakeSelection)
        {
            Int32 staticLength = fakeSelection.Length, curLength = message.Length,
                outputLength = noisifier.settings.outputLength;

            if (outputLength == 0)
                outputLength = curLength +
                    (Int32)Math.Pow
                    (
                        2,
                        Math.Min
                        (
                            10,
                            Math.Ceiling
                            (
                                Math.Log2(curLength)
                            )
                        )
                    );

            if (message.Length >= outputLength) return message;

            SecureRandom random  = new(128);
            List<char> withNoise = [.. message];
            Int32 placementId, noiseCount;

            while (curLength < outputLength)
            {
                if (outputLength - curLength > 2 && random.Next(2) == 0)
                {
                    placementId = random.Next(curLength);
                    noiseCount = Math.Min
                    (
                        curLength - placementId - 1,
                        random.Next
                        (
                            2,
                            (Int32)Math.Ceiling
                            (
                                Math.Sqrt(outputLength - curLength)
                            )
                        )
                    );

                    for (var count = 0; count < noiseCount - 2; count++)
                        withNoise.Insert
                        (
                            placementId,
                            fakeSelection[random.Next(staticLength)]
                        );

                    withNoise.Insert(placementId, noisifier.RandomComplexChar);
                    withNoise.Insert(placementId + noiseCount - 1, noisifier.RandomComplexChar);
                }
                else
                {
                    noiseCount = random.Next
                    (
                        1,
                        (Int32)Math.Ceiling
                        (
                            Math.Sqrt(outputLength - curLength)
                        )
                    );

                    for (var count = 0; count < noiseCount; count++)
                        withNoise.Insert
                        (
                            random.Next(withNoise.Count),
                            noisifier.RandomPrimaryChar
                        );
                }
                curLength = withNoise.Count;
            }

            return new string ([.. withNoise]) ?? "";
        }
        static public string NEW_INTERNAL_FastText(string message, Noisifier noisifier,
            string fakeSelection)
        {
            Int32 chunkSize = noisifier.settings.chunkSizeForSplitting;

            if (chunkSize < 1)
                throw new ArgumentException
                (
                    $"Impossible to split data into chunks of size: {chunkSize}",
                    nameof(noisifier.settings)
                );


            Int32 outputLength = noisifier.settings.outputLength,
                  curLength = message.Length;

            if (outputLength == 0)
            {
                outputLength = (Int32)Math.Pow
                (
                    2,
                    Math.Min
                    (
                        (Int32)noisifier.settings.boundaryAlignment,
                        Math.Ceiling
                        (
                            Math.Log2(curLength)
                        )
                    )
                );
                if (curLength > outputLength && 
                    noisifier.settings.useDynamicOutputAlignment)
                    outputLength *= (1 + curLength / outputLength);
            }
            if (message.Length >= outputLength) return message;


            Int32 maxAvgNoiseCount =
                Math.Max
                (
                    1,
                    (outputLength - curLength)
                    / (curLength + 1)
                ) * 2 + 1;
            Int32 maxSyntropy = Miscellaneous.CalculateMaxNonEntropy
                (
                    noisifier.settings.excpectedEntropy,
                    curLength,
                    outputLength
                );

            SecureRandom random = new(128);
            List<char> almostResult = new(outputLength);
            fakeSelection = fakeSelection == "" ? noisifier.PrimaryNoise : fakeSelection;
            Int32 prevFinalUnnoised = 0;


            for (var chunk = 0; chunk <= curLength; chunk += chunkSize)
            {
                random.Reseed();

                Int32 maxRoundLength =
                    Math.Min
                    (
                        (chunkSize + chunk),
                        curLength
                    )
                        * outputLength
                        / curLength
                        - almostResult.Count;
               

                almostResult.AddRange
                (
                    AdditionRound
                    (
                        [.. message.Substring
                        (
                            chunk,
                            Math.Min
                            (
                                curLength - chunk,
                                chunkSize
                            )
                        )],
                        fakeSelection,
                        noisifier,
                        random,
                        maxRoundLength,
                        maxSyntropy,
                        0,  //  minAvgNoiseCount
                        maxAvgNoiseCount,
                        ref prevFinalUnnoised
                    )
                );

                Console.Write($"\n\t{chunk / chunkSize})       ");
                Console.BackgroundColor = ConsoleColor.Red;
                Console.Write("".PadLeft(almostResult.Count, ' '));
                Console.BackgroundColor = ConsoleColor.Black;
            }




            return new string([.. almostResult]);


            //return INTERNAL_SplitIntoRounds
            //(
            //    message,
            //    noisifier,
            //    fakeSelection,
            //    outputLength
            //);
        }
        static private List<char> AdditionRound(
            List<char> message, string fakeSelection,
            Noisifier noisifier, SecureRandom random,
            Int32 maxRoundLength, Int32 maxSyntropy,
            Int32 minAvgNoiseCount, Int32 maxAvgNoiseCount,
            ref Int32 prevFinalUnnoised)
        {
            Int32 initialLength  = message.Count, chosenOffset;
            if   (initialLength >= maxRoundLength)
            {
                prevFinalUnnoised = initialLength;
                return message;
            }


            chosenOffset = random.Next
            (
                noisifier.settings.forceOptimalEntropy
                    && prevFinalUnnoised >= maxSyntropy
                    && minAvgNoiseCount <= 0 ?
                       minAvgNoiseCount + 1 : minAvgNoiseCount,
                Math.Min
                (
                    Math.Min
                    (
                        maxAvgNoiseCount,
                        maxRoundLength - message.Count + 1
                    ),
                    maxRoundLength - message.Count - initialLength / maxSyntropy + 1
                )
            );


            if (chosenOffset > 0)
            {
                prevFinalUnnoised = 1;

                if (chosenOffset >= 2 && random.NextBoolChance(
                    noisifier.settings.complexNoiseIntervalBiasPercents))
                {
                    message.InsertRange
                    (
                        0,
                        noisifier.RandomComplexSequence(2)
                    );

                    for (var i = 1; i < chosenOffset - 1; i++)
                    {
                        if (i < chosenOffset - 2 &&
                            random.NextBoolChance(
                                noisifier.settings.complexNoisePairBiasPercents))
                        {
                            message.InsertRange
                            (
                                1,
                                noisifier.RandomComplexSequence(2)
                            );

                            i++;
                        }
                        else if (random.NextBoolChance(
                                 noisifier.settings.primaryNoiseCharBiasPercents))
                            message.Insert
                            (
                                1,
                                noisifier.RandomPrimaryChar
                            );
                        else message.Insert
                            (
                                1,
                                fakeSelection
                                [
                                    random.Next(fakeSelection.Length)
                                ]
                            );
                    }
                }
                else message.InsertRange
                    (
                        0,
                        noisifier.RandomPrimarySequence(chosenOffset)
                    );
            }
            else prevFinalUnnoised += 2;


            if (message.Count >= maxRoundLength)
            {
                prevFinalUnnoised = message.Count - chosenOffset + 1;
                return message;
            }

            
            const Int32 minOffsetStep = 1;
            Int32 totalOffset = minOffsetStep + chosenOffset;


            for (var i = 1; i <= initialLength; i++)
            {
                chosenOffset = random.Next
                (
                    noisifier.settings.forceOptimalEntropy
                        && prevFinalUnnoised >= maxSyntropy
                        && i < initialLength
                        && minAvgNoiseCount <= 0 ?
                           minAvgNoiseCount + 1 : minAvgNoiseCount,
                    Math.Min
                    (
                        Math.Min
                        (
                            maxAvgNoiseCount,
                            maxRoundLength - message.Count + 1
                        ),
                        maxRoundLength - message.Count - (initialLength - i + 1) / maxSyntropy + 1
                    )
                );

                if (chosenOffset > 0)
                {
                    prevFinalUnnoised = 0;

                    if (chosenOffset >= 2 && random.NextBoolChance(
                        noisifier.settings.complexNoiseIntervalBiasPercents))
                    {
                        message.InsertRange
                        (
                            totalOffset,
                            noisifier.RandomComplexSequence(2)
                        );

                        for (var j = 1; j < chosenOffset - 1; j++)
                        {
                            if (j < chosenOffset - 2 &&
                            random.NextBoolChance(
                                noisifier.settings.complexNoisePairBiasPercents))
                            {
                                message.InsertRange
                                (
                                    totalOffset + minOffsetStep,
                                    noisifier.RandomComplexSequence(2)
                                );

                                j++;
                            }
                            else if (random.NextBoolChance(
                                noisifier.settings.primaryNoiseCharBiasPercents))
                                message.Insert
                                (
                                    totalOffset + minOffsetStep,
                                    noisifier.RandomPrimaryChar
                                );
                            else message.Insert
                                (
                                    totalOffset + minOffsetStep,
                                    fakeSelection
                                    [
                                        random.Next(fakeSelection.Length)
                                    ]
                                );
                        }
                    }
                    else message.InsertRange
                        (
                            totalOffset,
                            noisifier.RandomPrimarySequence(chosenOffset)
                        );
                }

                totalOffset += chosenOffset + minOffsetStep;

                if (message.Count >= maxRoundLength)
                {
                    prevFinalUnnoised = message.Count - totalOffset + 1;
                    return message;
                }

                prevFinalUnnoised++;
            }

            prevFinalUnnoised++;
            return message;
        }
        static private string INTERNAL_SplitIntoRounds(string message, Noisifier noisifier,
            string fakeSelection, Int32 outputLength = 0)
        {
            Int32 staticLength = fakeSelection.Length, curLength = message.Length;

            if (outputLength == 0)
                outputLength = curLength +
                    (Int32)Math.Pow
                    (
                        2,
                        Math.Min
                        (
                            10,
                            Math.Ceiling
                            (
                                Math.Log2(curLength)
                            )
                        )
                    );

            if (message.Length >= outputLength) return message;

            SecureRandom random = new(128);
            List<char> withNoise = [.. message];
            Int32 placementId, noiseCount;

            while (curLength < outputLength)
            {
                if (outputLength - curLength > 2 && random.Next(2) == 0)
                {
                    placementId = random.Next(curLength);
                    noiseCount = Math.Min
                    (
                        curLength - placementId - 1,
                        random.Next
                        (
                            2,
                            (Int32)Math.Ceiling
                            (
                                Math.Sqrt(outputLength - curLength)
                            )
                        )
                    );

                    for (var count = 0; count < noiseCount - 2; count++)
                        withNoise.Insert
                        (
                            placementId,
                            fakeSelection[random.Next(staticLength)]
                        );

                    withNoise.Insert(placementId, noisifier.RandomComplexChar);
                    withNoise.Insert(placementId + noiseCount - 1, noisifier.RandomComplexChar);
                }
                else
                {
                    noiseCount = random.Next
                    (
                        1,
                        (Int32)Math.Ceiling
                        (
                            Math.Sqrt(outputLength - curLength)
                        )
                    );

                    for (var count = 0; count < noiseCount; count++)
                        withNoise.Insert
                        (
                            random.Next(withNoise.Count),
                            noisifier.RandomPrimaryChar
                        );
                }
                curLength = withNoise.Count;
            }

            return new string([.. withNoise]) ?? "";
        }





        static public List<Byte> Bytes    (List<Byte> message, Template.IBinaryKey reKey)
        {
            throw new NotImplementedException();
        }
        static public List<Byte> FastBytes(List<Byte> message, Template.IBinaryKey reKey)
        {
            throw new NotImplementedException();
        }

        static public List<Byte> Bytes    (List<Byte> message, BinaryNoisifier noisifier)
        {
            throw new NotImplementedException();
        }
        static public List<Byte> FastBytes(List<Byte> message, BinaryNoisifier noisifier)
        {
            throw new NotImplementedException();
        }





        static private class Miscellaneous
        {
            private class SyntropyBiases(double valueBias, double powerBias)
            {
                public double valueBias = valueBias; 
                public double powerBias = powerBias;
            }



            static public Int32 CalculateMaxNonEntropy(
                ExpectedEntropy entropySetting,
                Int32 initial, Int32 extending)
            {
                return entropySetting == ExpectedEntropy.L0_Fast_Anything ?
                    initial : MaxSyntropy(initial, extending,
                    entropySetting switch
                    {
                        ExpectedEntropy.L1_Fast_Low =>
                            new SyntropyBiases(1.8, 1.55),
                        ExpectedEntropy.L2_Fast_Low =>
                            new SyntropyBiases(1.6, 1.5),


                        ExpectedEntropy.C0_Medium =>
                            new SyntropyBiases(1.5, 1.4),
                        ExpectedEntropy.C1_Medium =>
                            new SyntropyBiases(1.4, 1.33),
                        ExpectedEntropy.C2_Medium =>
                            new SyntropyBiases(1.4, 1.2),


                        ExpectedEntropy.H0_Slow_High =>
                            new SyntropyBiases(1.3, 1.2),
                        ExpectedEntropy.H1_Slow_High =>
                            new SyntropyBiases(1.2, 1.15),
                        ExpectedEntropy.H2_Slow_Maximal =>
                            new SyntropyBiases(1, 1.01),

                        _ => throw new NotImplementedException()
                    });
            }

            static private Int32 MaxSyntropy(
                Int32 initial, Int32 extending,
                SyntropyBiases syntropy)
                    => (Int32)Math.Ceiling
                    (
                        Math.Pow
                        (
                            initial * syntropy.valueBias /
                            (
                                extending - initial + 1
                            ),
                            syntropy.powerBias
                        )
                    );
        }
    }

    static public class RemoveNoise
    {
        static public string Text    (string message, Template.IEncryptionKey reKey)
        {
            throw new NotImplementedException();
        }
        static public string FastText(string message, Template.IEncryptionKey reKey)
        {
            throw new NotImplementedException();
        }

        static public string Text    (string message, Noisifier noisifier)
        {
            throw new NotImplementedException();
        }
        static public string FastText(string message, Noisifier noisifier)
        {
            throw new NotImplementedException();
        }



        static public List<Byte> Bytes    (List<Byte> message, Template.IBinaryKey reKey)
        {
            throw new NotImplementedException();
        }
        static public List<Byte> FastBytes(List<Byte> message, Template.IBinaryKey reKey)
        {
            throw new NotImplementedException();
        }

        static public List<Byte> Bytes    (List<Byte> message, BinaryNoisifier noisifier)
        {
            throw new NotImplementedException();
        }
        static public List<Byte> FastBytes(List<Byte> message, BinaryNoisifier noisifier)
        {
            throw new NotImplementedException();
        }
    }
}