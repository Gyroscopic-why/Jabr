using System;
using System.Collections.Generic;


using AVcontrol;



namespace JabrAPI.Source
{
    public class Noisifier
    {

    }

    public class BinaryNoisifier
    {
        private readonly SecureRandom _random = new(128);  //  Reseed after every 128 generated bytes (min possible amount)

        private readonly List<Byte> _primaryNoise = [];
        private readonly List<Byte> _complexNoise = [];

        private readonly List<Byte> _banned = [];
        private Byte _primaryCount = 8;
        private Byte _complexCount = 16;



        public BinaryNoisifier(List<Byte> primaryNoise, List<Byte> complexNoise)
            => Set(primaryNoise, complexNoise);
        public BinaryNoisifier(BinaryNoisifier otherNoisifier, bool fullCopy = true)
        {
            Set(otherNoisifier.PrimaryNoise, otherNoisifier.ComplexNoise);

            if (fullCopy)
                SetDefault
                (
                    otherNoisifier._banned,
                    otherNoisifier._primaryCount,
                    otherNoisifier._complexCount
                );
        }
        public BinaryNoisifier(List<Byte> banned, bool autoGenerate = true)
        {
            if (autoGenerate) Default(banned);
            else SetDefault(banned);
        }
        public BinaryNoisifier(List<Byte> exported) => ImportFromBinary(exported);
        public BinaryNoisifier()
            => SetDefault();



        List<Byte> PrimaryNoise => _primaryNoise;
        List<Byte> ComplexNoise => _complexNoise;
        List<Byte> Banned => _banned;





        static public bool IsPrimaryNoiseValidForKey(Template.IBinaryKey reKey, List<Byte> primaryNoise, bool throwException = false)
            => IsPrimaryNoiseValidForKey(reKey.FinalAlphabet, primaryNoise, throwException);
        static public bool IsPrimaryNoiseValidForKey(List<Byte>  exAlphabet, List<Byte> primaryNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                exAlphabet,
                primaryNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with ExternalAlphabet bytes",
                    nameof(primaryNoise)
                ),
                throwException
            );
        }
        static public bool IsPrimaryNoiseValidForMessage(List<Byte> message, List<Byte> primaryNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                message,
                primaryNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with message bytes",
                    nameof(primaryNoise)
                ),
                throwException
            );
        }

        public bool IsPrimaryNoiseValidForKey(Template.IBinaryKey reKey, bool throwException = false)
            => IsPrimaryNoiseValidForKey(reKey.FinalAlphabet, _primaryNoise, throwException);
        public bool IsPrimaryNoiseValidForKey(List<Byte> exAlphabet,  bool throwException = false)
            => IsPrimaryNoiseValidForKey(exAlphabet,  _primaryNoise,  throwException);
        public bool IsPrimaryNoiseValidForMessage(List<Byte> message, bool throwException = false)
            => IsPrimaryNoiseValidForMessage(message, _primaryNoise,  throwException);


        static public bool IsComplexNoiseValidForKey(Template.IBinaryKey reKey, List<Byte> complexNoise, bool throwException = false)
            => IsComplexNoiseValidForKey(reKey.FinalAlphabet, complexNoise, throwException);
        static public bool IsComplexNoiseValidForKey(List<Byte>  exAlphabet, List<Byte> complexNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                exAlphabet,
                complexNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with ExternalAlphabet bytes",
                    nameof(complexNoise)
                ),
                throwException
            );
        }
        static public bool IsComplexNoiseValidForMessage(List<Byte> message, List<Byte> complexNoise, bool throwException = false)
        {
            return IsNoiseValid
            (
                message,
                complexNoise,
                new ArgumentException
                (
                    $"PrimaryNoise bytes can not overlap with message bytes",
                    nameof(complexNoise)
                ),
                throwException
            );
        }

        public bool IsComplexNoiseValidForKey(Template.IBinaryKey reKey, bool throwException = false)
            => IsComplexNoiseValidForKey(reKey.FinalAlphabet, _complexNoise, throwException);
        public bool IsComplexNoiseValidForKey(List<Byte> exAlphabet,  bool throwException = false)
            => IsComplexNoiseValidForKey(exAlphabet,  _complexNoise,  throwException);
        public bool IsComplexNoiseValidForMessage(List<Byte> message, bool throwException = false)
            => IsComplexNoiseValidForMessage(message, _complexNoise,  throwException);



        static private bool IsNoiseValid(List<Byte> exAlphabet_or_message, List<Byte> primaryNoise_or_complexNoise,
            ArgumentException errorMessage, bool throwException = false)
        {
            foreach (Byte noiseByte in primaryNoise_or_complexNoise)
            {
                if (exAlphabet_or_message.Contains(noiseByte))
                {
                    if (throwException) throw new ArgumentException
                        (
                            errorMessage.Message +
                            $"\nDuplicate byte: {noiseByte}",
                            errorMessage.ParamName
                        );
                    return false;
                }
            }
            return true;
        }





        public void Next(bool throwExceptions = true)
        {
            try { GenerateAll(); }
            catch { if (throwExceptions) throw; }
        }
        public void Next(List<Byte> bannedForFailsafeRegeneration,
            bool resetSettingsToDefaultIfFailed = true, bool throwExceptions = true)
        {
            try
            {
                GenerateAll();
            }
            catch
            {
                if (resetSettingsToDefaultIfFailed)
                {
                    try
                    {
                        Default(bannedForFailsafeRegeneration);
                    }
                    catch
                    {
                        if (throwExceptions) throw;
                    }
                }
                else if (throwExceptions) throw;
            }
        }



        public bool ImportFromBinary(List<Byte> data, bool throwExceptions = false)
        {
            try
            {
                Byte primaryCount = data[0];
                if (data.Count < primaryCount + 1)
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Data length is insufficient for the specified primaryNoiseCount" +
                            $" {primaryCount} from data[0]",
                            nameof(data)
                        );
                    return false;
                }

                _primaryNoise.Clear();
                _primaryNoise.AddRange(data.GetRange(1, primaryCount));


                Byte complexCount = data[primaryCount + 1];
                if (data.Count < complexCount + primaryCount + 2)
                {
                    if (throwExceptions)
                        throw new ArgumentException
                        (
                            $"Data length is insufficient for the specified complexNoiseCount" +
                            $" {complexCount} from data[{primaryCount + 2}]",
                            nameof(data)
                        );
                    return false;
                }

                _complexNoise.Clear();
                _complexNoise.AddRange(data.GetRange(primaryCount + 2, complexCount));
            }
            catch
            {
                if (throwExceptions) throw;
                return false;
            }
            return true;
        }

        public List<Byte> ExportAsBinary()
        {
            List<Byte> result = [];

            result.Add((Byte)(_primaryNoise.Count));
            result.AddRange(_primaryNoise);

            result.Add((Byte)(_complexNoise.Count));
            result.AddRange(_complexNoise);

            return result;
        }



        public void SetDefault(List<Byte> banned, Byte primaryCount = 8, Byte complexCount = 16)
        {
            _banned.Clear();
            _banned.AddRange(banned);

            SetDefault(primaryCount, complexCount);
        }
        public void SetDefault(Byte primaryCount = 8, Byte complexCount = 16)
        {
            _primaryCount = primaryCount;
            _complexCount = complexCount;
        }

        public void SetDefaultOnlyPr(Byte primaryCount = 8)
            => _primaryCount = primaryCount;
        public void SetDefaultOnlyCplx(Byte complexCount = 16)
            => _complexCount = complexCount;

        public  void Default(List<Byte> banned)
        {
            SetDefault(banned);
            GenerateAll();
        }
        private void Set(List<Byte> primaryNoise, List<Byte> complexNoise)
        {
            _primaryNoise.Clear();
            _primaryNoise.AddRange(primaryNoise);

            _complexNoise.Clear();
            _complexNoise.AddRange(complexNoise);
        }



        private void GenerateAll()
        {
            GeneratePrimary(false);
            GenerateComplex(true);
        }



        private void ReconfigureNoiseParametersCount(Int32 allowedTotal)
        {
            if (allowedTotal < _primaryCount + _complexCount)
            {
                Byte compromiseLeft = (Byte)(allowedTotal / 3);
                _primaryCount = compromiseLeft;
                _complexCount = (Byte)(allowedTotal - compromiseLeft);
            }
        }
        private List<Byte> GetAllowedForDefaultCase(List<Byte> banned, Int32 reconfigureCount)
        {
            ReconfigureNoiseParametersCount(reconfigureCount);

            List<Byte> result = [];
            for (Byte noiseByte = 0; noiseByte < Byte.MaxValue; noiseByte++)
            {
                if (!banned.Contains(noiseByte)) result.Add(noiseByte);
            }
            return result;
        }
        private List<Byte> GetRemainingAllowedForPrimary(List<Byte> banned, bool banAlreadyUsedInComplex)
        {
            List<Byte> result = [];

            if (!banAlreadyUsedInComplex) result.AddRange(
                GetAllowedForDefaultCase(banned, 256 - banned.Count));
            else
            {
                for (Byte noiseByte = 0; noiseByte < Byte.MaxValue; noiseByte++)
                {
                    if (!banned.Contains(noiseByte) && !_complexNoise.Contains(noiseByte))
                        result.Add(noiseByte);
                }
            }

            while (result.Count > _primaryCount)
                result.RemoveAt(_random.Next(result.Count));

            return result;
        }
        private List<Byte> GetRemainingAllowedForComplex(List<Byte> banned, bool banAlreadyUsedInPrimary)
        {
            List<Byte> result = [];

            if (!banAlreadyUsedInPrimary) result.AddRange(
                GetAllowedForDefaultCase(banned, 256 - banned.Count));
            else
            {
                for (Byte noiseByte = 0; noiseByte < Byte.MaxValue; noiseByte++)
                {
                    if (!banned.Contains(noiseByte) && !_primaryNoise.Contains(noiseByte))
                        result.Add(noiseByte);
                }
            }

            while (result.Count > _complexCount)
                result.RemoveAt(_random.Next(result.Count));

            return result;
        }



        public List<Byte> GenerateNoise(Byte count, List<Byte> allowed)
        {
            List<Byte> result = [];

            for (var noiseByteId = 0; noiseByteId < count; noiseByteId++)
            {
                Int32 chosenId = _random.Next(result.Count);
                result.Insert(chosenId, allowed[noiseByteId]);
            }

            return result;
        }



        public void GeneratePrimary(List<Byte> banned, bool banAlreadyUsedInComplex)
        {
            //  Important to get allowed separately from GenerateNoise
            //  because _primaryCount can change here in default fail case
            List<Byte> allowed = GetRemainingAllowedForPrimary(banned, banAlreadyUsedInComplex);

            _primaryNoise.Clear();
            _primaryNoise.AddRange(GenerateNoise(_primaryCount, allowed));
        }
        public void GeneratePrimary(bool banAlreadyUsedInComplex)
            => GeneratePrimary(_banned, banAlreadyUsedInComplex);

        public void GenerateComplex(List<Byte> banned, bool banAlreadyUsedInPrimary)
        {
            //  Important to get allowed separately from GenerateNoise
            //  because _complexCount can change here in default fail case
            List<Byte> allowed = GetRemainingAllowedForComplex(banned, banAlreadyUsedInPrimary);

            _complexNoise.Clear();
            _complexNoise.AddRange(GenerateNoise(_primaryCount, allowed));
        }
        public void GenerateComplex(bool banAlreadyUsedInComplex)
            => GenerateComplex(_banned, banAlreadyUsedInComplex);
    }





    static public class AddNoise
    {
        static public string Text    (string message, Template.IEncryptionKey reKey)
        {
            throw new NotImplementedException();
        }
        static public string FastText(string message, Template.IEncryptionKey reKey)
        {
            throw new NotImplementedException();
        }

        static public string Text    (string message, Noisifier noisifier)
        {
            throw new NotImplementedException();
        }
        static public string FastText(string message, Noisifier noisifier)
        {
            throw new NotImplementedException();
        }



        static public List<Byte> Bytes    (List<Byte> message, Template.IBinaryKey reKey)
        {
            throw new NotImplementedException();
        }
        static public List<Byte> FastBytes(List<Byte> message, Template.IBinaryKey reKey)
        {
            throw new NotImplementedException();
        }

        static public List<Byte> Bytes    (List<Byte> message, BinaryNoisifier noisifier)
        {
            throw new NotImplementedException();
        }
        static public List<Byte> FastBytes(List<Byte> message, BinaryNoisifier noisifier)
        {
            throw new NotImplementedException();
        }
    }

    static public class RemoveNoise
    {
        static public string Text    (string message, Template.IEncryptionKey reKey)
        {
            throw new NotImplementedException();
        }
        static public string FastText(string message, Template.IEncryptionKey reKey)
        {
            throw new NotImplementedException();
        }

        static public string Text    (string message, Noisifier noisifier)
        {
            throw new NotImplementedException();
        }
        static public string FastText(string message, Noisifier noisifier)
        {
            throw new NotImplementedException();
        }



        static public List<Byte> Bytes    (List<Byte> message, Template.IBinaryKey reKey)
        {
            throw new NotImplementedException();
        }
        static public List<Byte> FastBytes(List<Byte> message, Template.IBinaryKey reKey)
        {
            throw new NotImplementedException();
        }

        static public List<Byte> Bytes    (List<Byte> message, BinaryNoisifier noisifier)
        {
            throw new NotImplementedException();
        }
        static public List<Byte> FastBytes(List<Byte> message, BinaryNoisifier noisifier)
        {
            throw new NotImplementedException();
        }
    }
}